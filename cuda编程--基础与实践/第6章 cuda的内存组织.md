![pic](./%E8%A1%A86-1%20CUDA%E4%B8%AD%E8%AE%BE%E5%A4%87%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E7%89%B9%E5%BE%81.png)
![pic](./cuda%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png)
访问速度：寄存器 > 共享内存  > 常量内存 > 纹理内存 > 全局内存、本地内存

可编程：·寄存器 ·共享内存 ·本地内存 ·常量内存 ·纹理内存 ·全局内存
不可编程：·一级缓存 ·二级缓存 ·只读常量缓存 ·只读纹理缓存
### 6.2.1 全局内存  
所有线程都可以访问。
之前例子中的d_x,d_y,d_z
### 6.2.2 常量内存
所有线程都可以访问。
常量内存驻留在设备内存中，并在每个SM专用的常量缓存中缓存。
有常量缓存的全局内存，数量有限，仅有64kb。
获得告诉访问的前提是一个线程束中的线程。
一个使用常量内存的方法：在核函数外使用__constant__定义变量，并使用cuda的API函数cudaMemoryToSymbol()从主机端复制到设备的常量内存后再使用。
### 6.2.3 纹理内存和表面内存
所有线程都可以访问。
纹理内存驻留在设备内存中，并在每个SM的只读缓存中缓存。
### 6.2.4 寄存器
速度最快
1、核函数中声明的一个没有其他修饰符的自变量
2、核函数中声明一个数组，用于引用该数组的索引是常量 且能在编译时确定
对于每个线程来说都是私有的
### 6.2.5 局部内存（本地内存）
核函数中符合存储在寄存器中但不能进入被该核函数分配的寄存器空间中的变量将溢 出到本地内存中。
溢出到本地内存中的变量本质上与全局内存在同一 块存储区域，
### 6.2.6 共享内存
__shared__修饰
一个线程块中的线程都可以访问，不同线程块中的值可以不同。
类似于CPU一级缓存。速度仅次于寄存器

### 6.2.7L1和L2缓存
不可编程的存储器
每个SM都有一个一级缓存，所有的SM共享一个二级缓存。一级和二级缓存都被用来 在存储本地内存和全局内存中的数据，也包括寄存器溢出的部分。
在CPU上，内存的加载和存储都可以被缓存。但是，在GPU上只有内存加载操作可以 被缓存，内存存储操作不能被缓存。
每个SM也有一个只读常量缓存和只读纹理缓存，它们用于在设备内存中提高来自于 各自内存空间内的读取性能。
![pic](./%E5%87%A0%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%8F%B7%E6%98%BE%E5%8D%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%86%85%E5%AD%98%E6%8C%87%E6%A0%87.png)